import "./chunk-WOOG5QLI.js";

// node_modules/@remotemerge/nepali-date-converter/ndc.js
var m = Object.defineProperty;
var p = (r, e, n) => e in r ? m(r, e, { enumerable: true, configurable: true, writable: true, value: n }) : r[e] = n;
var u = (r, e, n) => p(r, typeof e != "symbol" ? e + "" : e, n);
var y = Symbol.for("constructDateFrom");
function h(r, e) {
  return typeof r == "function" ? r(e) : r && typeof r == "object" && y in r ? r[y](e) : r instanceof Date ? new r.constructor(e) : new Date(e);
}
function c(r, e) {
  return h(r, r);
}
function g(r, e, n) {
  const a = c(r);
  return isNaN(e) ? h(r, NaN) : (e && a.setDate(a.getDate() + e), a);
}
function f(r) {
  const e = c(r), n = new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
  return n.setUTCFullYear(e.getFullYear()), +r - +n;
}
function w(r, ...e) {
  const n = h.bind(
    null,
    e.find((a) => typeof a == "object")
  );
  return e.map(n);
}
function d(r, e) {
  const n = c(r);
  return n.setHours(0, 0, 0, 0), n;
}
function T(r, e, n) {
  const [a, o] = w(
    n == null ? void 0 : n.in,
    r,
    e
  ), s = d(a), i = d(o), D = +s - f(s), l = +i - f(i);
  return Math.round((D - l) / 864e5);
}
function M(r, e) {
  const n = c(r);
  return n.setHours(23, 59, 59, 999), n;
}
function Y(r, e, n) {
  const a = +c(r), [o, s] = [
    +c(e.start),
    +c(e.end)
  ].sort((i, D) => i - D);
  return a >= o && a <= s;
}
var t = [];
t[1975] = [31, 31, 32, 32, 31, 30, 30, 29, 30, 29, 30, 30, 365];
t[1976] = [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 31, 366];
t[1977] = [30, 32, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31, 365];
t[1978] = [31, 31, 32, 31, 31, 31, 30, 29, 30, 29, 30, 30, 365];
t[1979] = t[1975];
t[1980] = t[1976];
t[1981] = [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 29, 31, 365];
t[1982] = t[1978];
t[1983] = t[1975];
t[1984] = t[1976];
t[1985] = [31, 31, 31, 32, 31, 31, 29, 30, 30, 29, 30, 30, 365];
t[1986] = t[1978];
t[1987] = [31, 32, 31, 32, 31, 30, 30, 29, 30, 29, 30, 30, 365];
t[1988] = t[1976];
t[1989] = [31, 31, 31, 32, 31, 31, 30, 29, 30, 29, 30, 30, 365];
t[1990] = t[1978];
t[1991] = [31, 32, 31, 32, 31, 30, 30, 30, 29, 29, 30, 30, 365];
t[1992] = [31, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31, 366];
t[1993] = t[1989];
t[1994] = t[1978];
t[1995] = t[1991];
t[1996] = t[1992];
t[1997] = t[1978];
t[1998] = [31, 31, 32, 31, 32, 30, 30, 29, 30, 29, 30, 30, 365];
t[1999] = t[1976];
t[2e3] = [30, 32, 31, 32, 31, 30, 30, 30, 29, 30, 29, 31, 365];
t[2001] = t[1978];
t[2002] = t[1975];
t[2003] = t[1976];
t[2004] = t[2e3];
t[2005] = t[1978];
t[2006] = t[1975];
t[2007] = t[1976];
t[2008] = t[1981];
t[2009] = t[1978];
t[2010] = t[1975];
t[2011] = t[1976];
t[2012] = t[1985];
t[2013] = t[1978];
t[2014] = t[1975];
t[2015] = t[1976];
t[2016] = t[1985];
t[2017] = t[1978];
t[2018] = t[1987];
t[2019] = t[1992];
t[2020] = t[1989];
t[2021] = t[1978];
t[2022] = t[1991];
t[2023] = t[1992];
t[2024] = t[1989];
t[2025] = t[1978];
t[2026] = t[1976];
t[2027] = t[2e3];
t[2028] = t[1978];
t[2029] = t[1998];
t[2030] = t[1976];
t[2031] = t[2e3];
t[2032] = t[1978];
t[2033] = t[1975];
t[2034] = t[1976];
t[2035] = t[1977];
t[2036] = t[1978];
t[2037] = t[1975];
t[2038] = t[1976];
t[2039] = t[1985];
t[2040] = t[1978];
t[2041] = t[1975];
t[2042] = t[1976];
t[2043] = t[1985];
t[2044] = t[1978];
t[2045] = t[1987];
t[2046] = t[1976];
t[2047] = t[1989];
t[2048] = t[1978];
t[2049] = t[1991];
t[2050] = t[1992];
t[2051] = t[1989];
t[2052] = t[1978];
t[2053] = t[1991];
t[2054] = t[1992];
t[2055] = t[1978];
t[2056] = t[1998];
t[2057] = t[1976];
t[2058] = t[2e3];
t[2059] = t[1978];
t[2060] = t[1975];
t[2061] = t[1976];
t[2062] = [30, 32, 31, 32, 31, 31, 29, 30, 29, 30, 29, 31, 365];
t[2063] = t[1978];
t[2064] = t[1975];
t[2065] = t[1976];
t[2066] = t[1981];
t[2067] = t[1978];
t[2068] = t[1975];
t[2069] = t[1976];
t[2070] = t[1985];
t[2071] = t[1978];
t[2072] = t[1987];
t[2073] = t[1976];
t[2074] = t[1989];
t[2075] = t[1978];
t[2076] = t[1991];
t[2077] = t[1992];
t[2078] = t[1989];
t[2079] = t[1978];
t[2080] = t[1991];
t[2081] = t[1992];
t[2082] = t[1989];
t[2083] = t[1978];
t[2084] = t[1976];
t[2085] = t[2e3];
t[2086] = t[1978];
t[2087] = t[1975];
t[2088] = t[1976];
t[2089] = t[2e3];
t[2090] = t[1978];
t[2091] = t[1975];
t[2092] = t[1976];
t[2093] = t[1981];
t[2094] = t[1978];
t[2095] = t[1975];
t[2096] = t[1976];
t[2097] = t[1985];
t[2098] = t[1978];
t[2099] = t[1975];
var E = class {
  constructor(e) {
    u(this, "startDate", /* @__PURE__ */ new Date("1918-04-13"));
    u(this, "endDate", /* @__PURE__ */ new Date("2043-04-13"));
    u(this, "dateRangeError", "The input date is out of supported range.");
    u(this, "inputYear");
    u(this, "inputMonth");
    u(this, "inputDate");
    const [n, a, o] = this.parseDateString(e);
    this.inputYear = n, this.inputMonth = a, this.inputDate = o;
  }
  /**
   * Parses and cleans the input date string.
   * Converts Nepali numerals to English and splits into year, month, and date.
   */
  parseDateString(e) {
    const n = this.numToEn(e).replace(/[./|,]/g, "-").trim(), [a, o, s] = n.split("-").map(Number);
    return [a, o, s];
  }
  /**
   * Converts Nepali numerals (०-९) to English numerals (0-9).
   */
  numToEn(e) {
    const n = ["०", "१", "२", "३", "४", "५", "६", "७", "८", "९"];
    return e.replace(
      /[०१२३४५६७८९]/g,
      (a) => n.indexOf(a).toString()
    );
  }
  /**
   * Converts a day index (0-6) to a day name (Sunday-Saturday).
   */
  numToDay(e) {
    return [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ][e];
  }
  /**
   * Calculates the AD date for a given BS date.
   * Uses the total days difference from the start date (1975-01-01 BS).
   */
  getAdDate(e, n, a) {
    let o = 0;
    for (let s = 1975; s < e; s++)
      o += t[s][12];
    for (let s = 0; s < n - 1; s++)
      o += t[e][s];
    return o += a - 1, g(this.startDate, o);
  }
  /**
   * Calculates the BS date for a given AD date.
   * Uses the total days difference from the start date (1975-01-01 BS).
   */
  getBsDate(e) {
    const n = new Date(e);
    let a = T(n, this.startDate);
    for (const o in t) {
      const s = t[o][12];
      if (a >= s) {
        a -= s;
        continue;
      }
      for (let i = 0; i < 12; i++) {
        const D = t[o][i];
        if (a >= D) {
          a -= D;
          continue;
        }
        return {
          year: Number(o),
          month: i + 1,
          date: a + 1
        };
      }
    }
    throw new Error(this.dateRangeError);
  }
  /**
   * Converts the input BS date to an AD date.
   * Returns an object with year, month, date, and day.
   */
  toAd() {
    if (this.inputYear < 1975 || this.inputYear > 2099)
      throw new Error(this.dateRangeError);
    const e = this.getAdDate(
      this.inputYear,
      this.inputMonth,
      this.inputDate
    ), n = this.numToDay(e.getDay());
    return {
      year: e.getFullYear(),
      month: e.getMonth() + 1,
      date: e.getDate(),
      day: n
    };
  }
  /**
   * Converts the input AD date to a BS date.
   * Returns an object with year, month, date, and day.
   */
  toBs() {
    const e = `${this.inputYear}-${this.inputMonth}-${this.inputDate}`, n = new Date(e);
    if (!Y(n, {
      start: d(this.startDate),
      end: M(this.endDate)
    }))
      throw new Error(this.dateRangeError);
    const a = this.getBsDate(e), o = this.numToDay(n.getDay());
    return { ...a, day: o };
  }
};
export {
  E as default
};
//# sourceMappingURL=@remotemerge_nepali-date-converter.js.map
